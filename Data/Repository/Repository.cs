using Microsoft.EntityFrameworkCore;
using SSRNMFSSN.Data.Models;
using SSRNMFSSN.Repository.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace SSRNMFSSN.Repository
{
    public abstract class Repository<T> : IRepository<T> where T : class
    {
        protected readonly DbContext _dbContext;
        protected readonly DbSet<T> _dbEntities;

        public Repository(SSRNMFSSNContext context)
        {
            _dbContext = context;
        }

        public virtual T GetById(int Id)
        {
            var temp = _dbContext.Set<T>().Find(Id);
            return temp;
        }

        public async Task<T> GetByIdAsync(int Id)
        {
            return await _dbContext.Set<T>().FindAsync(Id);
        }

        public virtual IEnumerable<T> GetAll()
        {
            try
            {
                return _dbContext.Set<T>().ToList();
            }
            catch (Exception e)
            {
                return null;
            }
        }

        public IEnumerable<T> Query(Expression<Func<T, T>> expression)
        {
            try
            {
                return _dbContext.Set<T>().Select(expression);
            }
            catch (Exception e)
            {
                return null;
            }
        }

        public async Task<IEnumerable<T>> GetAllAsync()
        {
            return await _dbContext.Set<T>().ToListAsync();
        }

        public int Count()
        {
            return _dbContext.Set<T>().Count<T>();
        }

        public async Task<int> CountAsync()
        {
            return await _dbContext.Set<T>().CountAsync<T>();
        }

        public IEnumerable<T> Find(Expression<Func<T, bool>> predicate)
        {
            return _dbContext.Set<T>().Where(predicate);
        }

        public async Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate)
        {
            var set = await _dbContext.Set<T>().ToListAsync();
            return set.AsQueryable().Where(predicate);
        }

        //we don't need an async version of this 
        //about AddAsync https://docs.microsoft.com/en-us/ef/core/api/microsoft.entityframeworkcore.dbset-1#Microsoft_EntityFrameworkCore_DbSet_1_AddAsync__0_System_Threading_CancellationToken_
        //This method is async only to allow special value generators, 
        //such as the one used by 'Microsoft.EntityFrameworkCore.Metadata.SqlServerValueGenerationStrategy.SequenceHiLo', 
        //to access the database asynchronously.For all other cases the non async method should be used.
        public virtual T Add(T entity)
        {
            T returnMe = _dbContext.Set<T>().Add(entity).Entity;
            SaveChanges();
            return returnMe;
        }

        public async Task<int> CompleteAsync()
        {
            return await _dbContext.SaveChangesAsync();
        }

        //we don't need an async version of this
        public virtual void Remove(T entity)
        {
            _dbContext.Set<T>().Remove(entity);
        }


        public virtual T Save(T entity, int id)
        {
            return SetValues(id, entity);
        }

        public virtual T UpdateEntity(T entity)
        {
            //the EF 2 way, for entities with autogenerated ids
            //_dbContext.Entry(entity).State = EntityState.Modified;
            var returnMe = _dbContext.Update(entity);
            saveChanges();
            return returnMe.Entity;
        }

        public virtual T SetValues(int id, T entity)
        {
            if (entity == null)
            {
                return null;
            }

            T existing = _dbContext.Set<T>().Find(id);

            if (existing != null)
            {
                _dbContext.Entry(existing).CurrentValues.SetValues(entity);
                saveChanges();
            }

            return entity;
        }


        private void saveChanges()
        {
            //handles concurrent modifications
            bool saveFailed;
            do
            {
                saveFailed = false;
                try
                {
                    _dbContext.SaveChanges();
                }
                catch (DbUpdateConcurrencyException ex)
                {
                    saveFailed = true;

                    // Update original values from the database
                    var entry = ex.Entries.Single();
                    entry.OriginalValues.SetValues(entry.GetDatabaseValues());
                }

            } while (saveFailed);
        }



        public void SaveChanges()
        {
            saveChanges();
        }

        private T stripVirtualProperties(T entity)
        {
            var props = typeof(T).GetProperties().Where(prop => prop.GetGetMethod().IsVirtual);

            foreach (var prop in props)
            {
                prop.SetValue(entity, null);
            }

            return entity;
        }

    }
}

